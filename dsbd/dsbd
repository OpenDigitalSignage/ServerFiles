#!/bin/bash
# dsb daemon written in shell
# /TR 2015-12-XX
#############################################

SMB="$1"
WEB="$2"
LOG="$3"
FIFO="$4"
CACHE="$5"

# javascript files and templates
FILES="/var/lib/dsb"
TEMPLATES="$SMB/Templates"

# "Background"
# - Background sollte nur 1x vorkommen
# - wird nicht als iframe generiert
# - hat style f체r das frameset

# "Wetter"
# - wetter hat 3 buttons

# "Ticker"
# - ticker hat ticker.txt

# "SlideShow"
# - slideshow hat verzeichnis
# - alle bilder darin werden angezeigt
# - optionen via.?

# "Uhr"
# - hat auch optionen

# "Webseite"
# - nur eine webseite als option

# "Newsfeed"
# - einen feed und diverse einstellungen

exec 1>>$LOG
exec 2>&1

# log sth.
log() {
  d=`date "+%Y-%m-%d %H:%M:%S"`
  echo "[$d] $*" >> $LOG
}

# exit with some error
error() {
  log "$*"
  exit 1
}

# called once in beginning
startup() {
  log "START SERVICE"

  # test for some tools, which are needed
  test -x /usr/bin/ffmpeg || error "Need ffmpeg!"
  test -x /usr/bin/mutool || error "Need mutool!"
  test -x /usr/bin/dos2unix || error "Need dos2unix!"
  test -x /usr/bin/libreoffice || error "Need libreoffice!"

  # register cleanup function
  trap cleanup SIGHUP SIGINT SIGTERM SIGQUIT

  # libreoffice setup, we want nice pdf output!
  # https://wiki.openoffice.org/wiki/API/Tutorials/PDF_export
  CFG="$HOME/.config/libreoffice/4/user/registrymodifications.xcu"
  mkdir -p `dirname $CFG`
  cat <<EOF > $CFG
<?xml version="1.0" encoding="UTF-8"?>
<oor:items xmlns:oor="http://openoffice.org/2001/registry" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
<item oor:path="/org.openoffice.Office.Common/Filter/PDF/Export"><prop oor:name="ExportFormFields" oor:op="fuse"><value>false</value></prop></item>
<item oor:path="/org.openoffice.Office.Common/Filter/PDF/Export"><prop oor:name="IsAddStream" oor:op="fuse"><value>false</value></prop></item>
<item oor:path="/org.openoffice.Office.Common/Filter/PDF/Export"><prop oor:name="MaxImageResolution" oor:op="fuse"><value>1200</value></prop></item>
<item oor:path="/org.openoffice.Office.Common/Filter/PDF/Export"><prop oor:name="ReduceImageResolution" oor:op="fuse"><value>false</value></prop></item>
<item oor:path="/org.openoffice.Office.Common/Filter/PDF/Export"><prop oor:name="UseLosslessCompression" oor:op="fuse"><value>true</value></prop></item>
<item oor:path="/org.openoffice.Office.Common/Filter/PDF/Export"><prop oor:name="SelectPdfVersion" oor:op="fuse"><value>1</value></prop></item>
<item oor:path="/org.openoffice.Office.Common/Filter/PDF/Export"><prop oor:name="Quality" oor:op="fuse"><value>100</value></prop></item>
EOF

  mkdir -p "$TEMPLATES"
  cd $CACHE || error "Could not change to cachedir $CACHE"
}

# called once on end
cleanup() {
  log "END SERVICE"
  kill $INOTIFY_PID
  exit 0
}

###### xxx
# document.getElementById('some_frame_id').contentWindow.location.reload();


# -> direct ins web
conv_image() {
  cp $1 $2
}

# pdf, xps, cbz, and epub -> image
conv_pdf() {
  mutool draw -r 128 -o "%03d.png" puehlhofer_samstag_jan06_mitreferenzen.pdf
}

# office -> pdf -> image
# - wichtig, libreoffice einmal starten und pdf export qualit채t festlegen
conv_office() {
  libreoffice --convert-to "pdf" --headless $*
}

conv_video() {
  echo "lala"
}

generate_index() {
  if_styles=`cat "$CACHE/iframe-styles"`
  if_links=`cat "$CACHE/iframe-links"`
  cat <<EOF > "$WEB/index.html"
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <script type="text/javascript" src="js/jquery.min.js"></script>
  <script type="text/javascript" src="js/dsb.js"></script>

  <style>
  %STYLE%
  $if_styles
  </style>
</head>

<body>

<!-- hier kommen die iframe tags rein -->
$if_links

<!-- hintergrund -->
<div id="bg"></div>
<script type="text/javascript">
  dsb_background("images.txt", "bg");
  dsb_checkreload("images.txt", 5);
</script>

</body>
</html>
EOF
}

# Inhalt eines Templates lesen und zur체ck geben
read_template_file() {
  SysDir="$1"
  UserDir="$2"
  File="$3"
  Default="$4"

  find "$UserDir" -iname "$File" | while read f; do
    cat "$f"
    echo "r1"
    return 0
  done

  find "$SysDir" -iname "$File" | while read f; do
    cat "$f"
    echo "r2"
    return 0
  done

  echo "r3"
  echo "$Default"
}

# "Ticker"
# - ticker hat ticker.txt

# "SlideShow"
# - slideshow hat verzeichnis
# - alle bilder darin werden angezeigt
# - optionen via.?

# "Uhr"
# - hat auch optionen

# "Webseite"
# - nur eine webseite als option

# "Newsfeed"
# - einen feed und diverse einstellungen
generate_iframe_newsfeed() {
  Id="$1"
  Section="$2"

  # System and User Template
  Template="$TEMPLATES/Newsfeed"
  UserTemplate="$SMB/$Section"
  mkdir -p "$UserTemplate"

  LAYOUT=`read_template_file  "$Template" "$UserTemplate" "Layout.txt" ""`
  OPTIONEN=`read_template_file  "$Template" "$UserTemplate" "Optionen.txt" ""`
  STYLE=`read_template_file   "$Template" "$UserTemplate" "Style.txt" ""`

  UserDir="$SMB/$Section"
  echo "$LAYOUT"   > "$UserDir/Layout.txt"
  echo "$OPTIONEN" > "$UserDir/Optionen.txt"
  echo "$STYLE"    > "$UserDir/Style.txt"

  LAYOUT=${LAYOUT/'%STYLE%'/"$STYLE"}
  LAYOUT=${LAYOUT/'%OPTIONEN%'/"$OPTIONEN"}
  echo "$LAYOUT"  > "$UserDir/if_Wetter.txt"
}

# Type=Wetter Section="Wetter #1"
generate_iframe_wetter() {
  Id="$1"
  Section="$2"

  # System and User Template
  Template="$TEMPLATES/Wetter"
  UserTemplate="$SMB/$Section"
  mkdir -p "$UserTemplate"

  LAYOUT=`read_template_file  "$Template" "$UserTemplate" "Layout.txt" ""`
  STYLE=`read_template_file   "$Template" "$UserTemplate" "Style.txt" ""`
  BUTTON1=`read_template_file "$Template" "$UserTemplate" "Button1.txt" "Wetterbutton 1 nicht gesetzt!"`
  BUTTON2=`read_template_file "$Template" "$UserTemplate" "Button2.txt" "Wetterbutton 2 nicht gesetzt!"`
  BUTTON3=`read_template_file "$Template" "$UserTemplate" "Button3.txt" "Wetterbutton 3 nicht gesetzt!"`

  UserDir="$SMB/$Section"
  echo "$LAYOUT"  > "$UserDir/Layout.txt"
  echo "$STYLE"   > "$UserDir/Style.txt"
  echo "$BUTTON1" > "$UserDir/Button1.txt"
  echo "$BUTTON2" > "$UserDir/Button2.txt"
  echo "$BUTTON3" > "$UserDir/Button3.txt"

  LAYOUT=${LAYOUT/'%STYLE%'/"$STYLE"}
  LAYOUT=${LAYOUT/'%BUTTON1%'/"$BUTTON1"}
  LAYOUT=${LAYOUT/'%BUTTON2%'/"$BUTTON2"}
  LAYOUT=${LAYOUT/'%BUTTON3%'/"$BUTTON3"}
  echo "$LAYOUT"  > "$UserDir/if_Wetter.txt"

  echo "iframe#links {
   position: fixed;
   top: ${TOP[$id]}; left: ${LEFT[$id]};
   width: ${WIDTH[$id]}; height: ${HEIGHT[$id]};
  }" >> "$CACHE/iframe-styles"

  # <iframe id="wetter" src="if_wetter.html" frameborder="0" scrolling="no"></iframe>
  #echo -n > "$CACHE/iframe-links"
  echo "<iframe id=\"id$id\" src=\"if_$id.html\" frameborder=\"0\" scrolling=\"no\"></iframe>" \
    >> "$CACHE/iframe-links"
}

generate_iframe() {
  id="$1"

  # "Wetter #1"
  Section="${SECTIONS[$id]}"

  # Types: Background Wetter Ticker SlideShow Uhr Webseite Newsfeed
  Type="${TYPES[$id]}"

  case "$Type" in
    "Wetter")
      generate_iframe_wetter "$id" "$Section"
      ;;
    "Ticker1")
      generate_iframe_ticker "$Section"
      ;;
    "SlideShow1")
      generate_iframe_slideshow "$Section"
      ;;
    "Uhr1")
      generate_iframe_uhr "$Section"
      ;;
    "Webseite1")
      generate_iframe_webseite "$Section"
      ;;
    "Newsfeed1")
      generate_iframe_newsfeed "$Section"
      ;;
  esac
}

# read layout file and set the array SECTIONS + TYPES
read_layout() {
  file="$1"
  i="-1"
  while IFS=$'' read var val; do
    # section found
    if [[ $var == \[* ]]; then
      # sectionen die mit '#' beginnen, ignorieren
      x=`echo "$var"|tr -d "[]"|grep -v '^#'`
      test "x$x" = "x" && continue
      i=$((i+1))
      SECTIONS[$i]="$x"
    fi
    if [[ $var == Type=* ]]; then x=`echo "$var"|cut -b 6-`; TYPES[$i]="$x"; fi
    if [[ $var == Left=* ]]; then x=`echo "$var"|cut -b 6-`; LEFT[$i]="$x"; fi
    if [[ $var == Top=* ]]; then x=`echo "$var"|cut -b 5-`; TOP[$i]="$x"; fi
    if [[ $var == Width=* ]]; then x=`echo "$var"|cut -b 7-`; WIDTH[$i]="$x"; fi
    if [[ $var == height=* ]]; then x=`echo "$var"|cut -b 8-`; HEIGHT[$i]="$x"; fi
  done < "$file"

  # create directories / files in $SMB and $WEB
  echo -n > "$CACHE/iframe-styles"
  echo -n > "$CACHE/iframe-links"
  for i in ${!SECTIONS[@]}; do
    # 1) nur die iframes generieren
    generate_iframe $i
  done

  # 2) index f체r die iframes generieren
  generate_index
  
  # 3) cleanup
  rm -f "$CACHE/iframe-*"
}

remove_layout() {
  for i in ${!SECTIONS[@]}; do
    rm -rf "$SMB/${SECTIONS[$i]}" "$WEB/${SECTIONS[$i]}"
  done
  SECTIONS=""
}

# read_value "file.ini" "section" "key" "default"
read_value() {
  file="$1"
  section="$2"
  key="$3"
  value="$4"
  found="0"
  while IFS=$'=' read var val; do
    if [[ $var == \[* ]]; then
      v=`echo "$var"|tr -d "[]"|grep -v '^#'`
      if [ "x$section" = "x$v" ]; then
        found="1"
      else
        found="0"
      fi
    fi
    if [[ $val ]]; then
      if [ "x$found" = "x1" -a $key = $var ]; then
        echo "$val"
        return
      fi
    fi
  done < "$file"
  # default value
  echo "$value"
}

# file was created @ $SMB
handle_create() {
  fullpath="$1"
  directory="$2"
  basefile="$3"

  log "handle_create file($basefile) dir($directory) orig($fullpath)"

  # special file "Layout.dsb"
  if [ "${basefile}" = "layout.dsb" ]; then
    cat "$fullpath" | dos2unix > "$CACHE/$basefile"
    read_layout "$CACHE/$basefile"
    rm -f "$CACHE/$basefile"
    return
  fi
}

# file was removed in $SMB
handle_delete() {
  fullpath="$1"
  directory="$2"
  basefile="$3"

  log "handle_delete file($basefile) dir($directory) orig($fullpath)"

  # special file "Layout.dsb"
  if [ "${basefile}" = "layout.dsb" ]; then
    remove_layout
    return
  fi
}

# some error checking and initializing
test -z $5 && error "Need 5 parameter!"
startup

# globals arrays for the layout
declare -A "SECTIONS" "TYPES" "LEFT" "TOP" "WIDTH" "HEIGHT"

# start inotifywait and put in background
inotifywait --monitor --recursive \
  --event create,close_write,delete,moved_to,moved_from \
  --format "|%w%f|%e|" "$SMB" > "$FIFO" 2>&1 &
INOTIFY_PID=$?

# big loop, which starts things on some events
waiting="yes"
while read line; do

  # wait for inotify to be ready
  if [ "$waiting" = "yes" ]; then
    test "$line" = "Watches established." || continue
    waiting="no"

    # touch all files in smb root (force reading them)
    for i in $SMB/*; do
      test -f "$i" && touch "$i"
    done
    continue
  fi

  # thats the real input now
  fullpath=`echo $line|cut -d'|' -f2`
  event=`echo $line|cut -d'|' -f3`

  # remove $SMB prefix
  # /home/dsb/dsb1/path/file.txt -> path/file.txt
  lc_filename=${fullpath#$SMB/}

  # we need a name, if there is none, we can't do anything...
  test "x$lc_filename" = "x" && continue

  # lower case directory and basefile without smb prefix
  directory=`dirname "${lc_filename,,}"`
  basefile=`basename "${lc_filename,,}"`

  # debugging:
  # log "filename($filename) e($event)"
  # log "directory($directory) basefile($basefile) e($event)"
  # continue

  # .files are ignored
  [ "${basefile:0:1}" = "." ] && continue

  # create / delete
  case "$event" in
    "CREATE")
      handle_create "$fullpath" "$directory" "$basefile"
    ;;
    "CLOSE_WRITE,CLOSE")
      handle_create "$fullpath" "$directory" "$basefile"
    ;;
    "MOVED_TO")
      handle_create "$fullpath" "$directory" "$basefile"
    ;;
    "MOVED_FROM")
      handle_delete "$fullpath" "$directory" "$basefile"
    ;;
    "DELETE")
      handle_delete "$fullpath" "$directory" "$basefile"
    ;;
  esac
done < "$FIFO"
