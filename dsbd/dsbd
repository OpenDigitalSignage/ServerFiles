#!/bin/bash
# dsb daemon written in shell
# /TR 2015-12-XX
#############################################

SMB="$1"
WEB="$2"
LOG="$3"
FIFO="$4"
CACHE="$5"

# javascript files and templates
LIBFILES="/var/lib/dsb"
TEMPLATES="$LIBFILES/Templates"

# time in seconds
DSB_RELOAD_TIME="2"
PDF_QUALITY="80"

exec 1>>$LOG
exec 2>&1

# fifo, alles @ fd 23
exec 23<>${FIFO}
FIFO_FD=23

# log sth.
log() {
  d=`date "+%Y-%m-%d %H:%M:%S"`
  echo "[$d] $*" >> $LOG
}

# exit with some error
error() {
  log "$*"
  exit 1
}

# called once in beginning
startup() {
  log "START SERVICE"

  # test for some tools, which are needed
  test -x /usr/bin/rsync || error "Need rsync!"
  test -x /usr/bin/ffmpeg || error "Need ffmpeg!"
  test -x /usr/bin/mutool || error "Need mutool!"
  test -x /usr/bin/dos2unix || error "Need dos2unix!"
  test -x /usr/bin/libreoffice || error "Need libreoffice!"

  # register cleanup function
  trap cleanup SIGHUP SIGINT SIGTERM SIGQUIT

  # libreoffice setup, we want nice pdf output!
  # https://wiki.openoffice.org/wiki/API/Tutorials/PDF_export
  CFG="$HOME/.config/libreoffice/4/user/registrymodifications.xcu"
  mkdir -p `dirname $CFG`
  cat <<EOF > $CFG
<?xml version="1.0" encoding="UTF-8"?>
<oor:items xmlns:oor="http://openoffice.org/2001/registry" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
<item oor:path="/org.openoffice.Office.Common/Filter/PDF/Export"><prop oor:name="ExportFormFields" oor:op="fuse"><value>false</value></prop></item>
<item oor:path="/org.openoffice.Office.Common/Filter/PDF/Export"><prop oor:name="IsAddStream" oor:op="fuse"><value>false</value></prop></item>
<item oor:path="/org.openoffice.Office.Common/Filter/PDF/Export"><prop oor:name="MaxImageResolution" oor:op="fuse"><value>300</value></prop></item>
<item oor:path="/org.openoffice.Office.Common/Filter/PDF/Export"><prop oor:name="ReduceImageResolution" oor:op="fuse"><value>true</value></prop></item>
<item oor:path="/org.openoffice.Office.Common/Filter/PDF/Export"><prop oor:name="UseLosslessCompression" oor:op="fuse"><value>false</value></prop></item>
<item oor:path="/org.openoffice.Office.Common/Filter/PDF/Export"><prop oor:name="SelectPdfVersion" oor:op="fuse"><value>1</value></prop></item>
<item oor:path="/org.openoffice.Office.Common/Filter/PDF/Export"><prop oor:name="Quality" oor:op="fuse"><value>90</value></prop></item>
EOF

  cd $CACHE || error "Could not change to cachedir $CACHE"
}

# called once on end
cleanup() {
  log "END SERVICE"
  kill $INOTIFY_PID
  exit 0
}

# called, when we know all other updates do not need more work
clean_fifo() {
  counter=0
  while true; do
    # no data @ pipe
    read -t 0.01 -u $FIFO_FD ignored
    test "$?" != "0" && break
    counter=$((counter+1))
    # echo "ignoring line: $ignored"
  done
  if [ "$counter" != "0" ]; then
    log "Anzahl ignorierter Inotify's: $counter"
  fi
}

# -> direct ins web
conv_direct() {
  FileName="$1"
  Dir=`dirname "$FileName"`
  Base=`basename "$FileName"`

  log "conv_direct($1)"
  rm -rf "$Dir/$Base.d"
  mkdir -p "$Dir/$Base.d"
  ln -s "$FileName" "$Dir/$Base.d/$Base"
  ls "$Dir/$Base.d" > "$FileName.txt"
  # liste machen
  find "$Dir/${Base}.d" -type l | sort > "$Dir/${Base}.txt"
}

conv_video() {
  FileName="$1"
  Dir=`dirname "$FileName"`
  Base=`basename "$FileName"`

  log "conv_video($1)"
  rm -rf "$Dir/$Base.d"
  mkdir -p "$Dir/$Base.d"
  ln -s "$FileName" "$Dir/$Base.d/$Base"
  ls "$Dir/$Base.d" > "$FileName.txt"
  # liste machen
  find "$Dir/${Base}.d" -type l | sort > "$Dir/${Base}.txt"
}

# convert via Image Magick comvert tool
conv_image() {
  FileName="$1"
  Dir=`dirname "$FileName"`
  Base=`basename "$FileName"`

  log "conv_image($1)"
  rm -rf "$Dir/$Base.d"
  mkdir -p "$Dir/$Base.d"
  convert "$FileName" "$Dir/$Base.d/$Base.png"
  # liste machen
  find "$Dir/${Base}.d" -name "*.png" | sort > "$Dir/${Base}.txt"
}

# pdf, xps, cbz, and epub -> png
conv_pdf() {
  FileName="$1"
  Dir=`dirname "$FileName"`
  Base=`basename "$FileName"`

  log "conv_pdf($1) -> $Dir/${Base}.txt"
  # /dsb1-cache/SlideShow #1/FILE.pdf.d/FILE_001.png ...FILE_00N.png
  # altes CacheDir löschen und neues erstellen
  rm -rf "$Dir/$Base.d"
  mkdir -p "$Dir/$Base.d"
  mutool draw -r $PDF_QUALITY -o "$Dir/${Base}.d/${Base}_%03d.png" "$FileName"
  # liste machen
  find "$Dir/${Base}.d" -name "*.png" | sort > "$Dir/${Base}.txt"
}

# office -> pdf -> image
# - wichtig, libreoffice einmal starten und pdf export qualität festlegen
conv_office() {
  FileName="$1"
  Dir=`dirname "$FileName"`
  Base=`basename "$FileName"`
  BaseNoExt=${Base%.*}

  log "conv_office($1)"
  rm -rf "$Dir/$Base.d"
  mkdir -p "$Dir/$Base.d"
  cp "$FileName" "$Dir/$Base.d"
  cd "$Dir/$Base.d"
  # office nach pdf:
  unoconv -f pdf --pipe="pipe$$" "$Base"
  rm -f "$Base"
  # pdf nach png:
  mutool draw -r $PDF_QUALITY -o "${Base}_%03d.png" "$BaseNoExt.pdf"
  rm -f "$BaseNoExt.pdf"
  # liste machen
  find "$Dir/${Base}.d" -name "*.png" | sort > "$Dir/${Base}.txt"
  cd $CACHE
}

# eine mediendatei in den cache schieben
cache_file() {
  Src="$1"
  Dst="$2"
  File="$3"

  # overwrite old one...
  cp -f "$Src/$File" "$Dst/$File"

  # lower case filename
  lcFile=${File,,}

  # motool draw
  [ "${lcFile: -4}" = ".pdf" ] && conv_pdf "$Dst/$File"
  [ "${lcFile: -4}" = ".xps" ] && conv_pdf "$Dst/$File"
  [ "${lcFile: -4}" = ".cbz" ] && conv_pdf "$Dst/$File"
  [ "${lcFile: -5}" = ".epub" ] && conv_pdf "$Dst/$File"

  # libreoffice (nicht alle)
  [ "${lcFile: -4}" = ".cwk" ] && conv_office "$Dst/$File" # AppleWorks word processing
  [ "${lcFile: -4}" = ".dxf" ] && conv_office "$Dst/$File" # AutoCAD DXF
  [ "${lcFile: -4}" = ".cdr" ] && conv_office "$Dst/$File" # CorelDRAW 6-X7
  [ "${lcFile: -4}" = ".cmx" ] && conv_office "$Dst/$File" # CorelDRAW 6-X7
  [ "${lcFile: -4}" = ".dbf" ] && conv_office "$Dst/$File" # dBase
  [ "${lcFile: -4}" = ".wk1" ] && conv_office "$Dst/$File" # Lotus 1-2-3
  [ "${lcFile: -4}" = ".wks" ] && conv_office "$Dst/$File" # Lotus 1-2-3
  [ "${lcFile: -4}" = ".123" ] && conv_office "$Dst/$File" # Lotus 1-2-3
  [ "${lcFile: -4}" = ".hwp" ] && conv_office "$Dst/$File" # Hangul WP 97
  [ "${lcFile: -4}" = ".mml" ] && conv_office "$Dst/$File" # MathML
  [ "${lcFile: -4}" = ".xls" ] && conv_office "$Dst/$File" # MS Excel 4/5/95/97–2003
  [ "${lcFile: -4}" = ".xlw" ] && conv_office "$Dst/$File" # MS Excel 4/5/95/97–2003
  [ "${lcFile: -4}" = ".xlt" ] && conv_office "$Dst/$File" # MS Excel 4/5/95/97–2003
  [ "${lcFile: -5}" = ".docx" ] && conv_office "$Dst/$File" # MS Office 2007 Office Open XML
  [ "${lcFile: -5}" = ".xlsx" ] && conv_office "$Dst/$File" # MS Office 2007 Office Open XML
  [ "${lcFile: -5}" = ".pptx" ] && conv_office "$Dst/$File" # MS Office 2007 Office Open XML
  [ "${lcFile: -4}" = ".pxl" ] && conv_office "$Dst/$File" # MS Pocket Excel
  [ "${lcFile: -4}" = ".psw" ] && conv_office "$Dst/$File" # MS Pocket Word
  [ "${lcFile: -4}" = ".ppt" ] && conv_office "$Dst/$File" # MS PowerPoint 97–2003
  [ "${lcFile: -4}" = ".pps" ] && conv_office "$Dst/$File" # MS PowerPoint 97–2003
  [ "${lcFile: -4}" = ".pot" ] && conv_office "$Dst/$File" # MS PowerPoint 97–2003
  [ "${lcFile: -4}" = ".rtf" ] && conv_office "$Dst/$File" # MS RTF
  [ "${lcFile: -4}" = ".doc" ] && conv_office "$Dst/$File" # MS Word 4/5/6.0/95/97–2003
  [ "${lcFile: -4}" = ".dot" ] && conv_office "$Dst/$File" # MS Word 4/5/6.0/95/97–2003
  [ "${lcFile: -4}" = ".vsd" ] && conv_office "$Dst/$File" # MS Visio
  [ "${lcFile: -4}" = ".psd" ] && conv_office "$Dst/$File" # PhotoShop
  [ "${lcFile: -4}" = ".odt" ] && conv_office "$Dst/$File" # OpenDocument Text
  [ "${lcFile: -4}" = ".ods" ] && conv_office "$Dst/$File" # OpenDocument ...
  [ "${lcFile: -4}" = ".odp" ] && conv_office "$Dst/$File" # OpenDocument
  [ "${lcFile: -4}" = ".odb" ] && conv_office "$Dst/$File" # OpenDocument
  [ "${lcFile: -4}" = ".odg" ] && conv_office "$Dst/$File" # OpenDocument
  [ "${lcFile: -4}" = ".odf" ] && conv_office "$Dst/$File" # OpenDocument
  [ "${lcFile: -4}" = ".sxw" ] && conv_office "$Dst/$File" # OpenOffice.org XML
  [ "${lcFile: -4}" = ".stw" ] && conv_office "$Dst/$File" # OpenOffice.org XML
  [ "${lcFile: -4}" = ".sxc" ] && conv_office "$Dst/$File" # OpenOffice.org XML
  [ "${lcFile: -4}" = ".sxi" ] && conv_office "$Dst/$File" # OpenOffice.org XML
  [ "${lcFile: -4}" = ".sti" ] && conv_office "$Dst/$File" # OpenOffice.org XML
  [ "${lcFile: -4}" = ".sxd" ] && conv_office "$Dst/$File" # OpenOffice.org XML
  [ "${lcFile: -4}" = ".std" ] && conv_office "$Dst/$File" # OpenOffice.org XML
  [ "${lcFile: -4}" = ".sxm" ] && conv_office "$Dst/$File" # OpenOffice.org XML
  [ "${lcFile: -4}" = ".wb2" ] && conv_office "$Dst/$File" # Quattro Pro 6.0
  [ "${lcFile: -4}" = ".wmf" ] && conv_office "$Dst/$File" # Windows Meta File
  [ "${lcFile: -4}" = ".wpd" ] && conv_office "$Dst/$File" # WordPerfect
  [ "${lcFile: -4}" = ".wps" ] && conv_office "$Dst/$File" # WordPerfect Suite 2000/Office 1.0

  # images, welche nicht alle browser können
  [ "${lcFile: -4}" = ".pcx" ] && conv_image "$Dst/$File" # PCX
  [ "${lcFile: -4}" = ".bmp" ] && conv_image "$Dst/$File"

  # alle weiteren werden nicht konvertiert, nur anzeigen
  [ "${lcFile: -4}" = ".jpg" ] &&  conv_direct "$Dst/$File"
  [ "${lcFile: -4}" = ".png" ] &&  conv_direct "$Dst/$File"
  [ "${lcFile: -4}" = ".gif" ] &&  conv_direct "$Dst/$File"

  # video dateien
  [ "${lcFile: -4}" = ".avi" ] &&  conv_video "$Dst/$File"
  [ "${lcFile: -4}" = ".mp4" ] &&  conv_video "$Dst/$File"
  [ "${lcFile: -4}" = ".m4v" ] &&  conv_video "$Dst/$File"
  [ "${lcFile: -4}" = ".ogm" ] &&  conv_video "$Dst/$File"
  [ "${lcFile: -4}" = ".ogv" ] &&  conv_video "$Dst/$File"
  [ "${lcFile: -4}" = ".ogg" ] &&  conv_video "$Dst/$File"
  [ "${lcFile: -5}" = ".webm" ] &&  conv_video "$Dst/$File"
}

# Bilder und andere Mediendateien einlesen bzw. konvertieren
read_mediafiles() {
  # log "read_mediafiles id($Id)"

  # UserDir = Files aus dem Samba Share
  # CacheDir = dort wandeln wir um, *.txt wird ignoriert
  UserDir="$SMB/$Section"
  CacheDir="$CACHE/$Section"
  mkdir -p "$CacheDir"

  # xxx - ganz anders hier...

  # cleanup old one, if there
  echo -n > "$WEB/if_$Id.txt"
  rm -rf "$WEB/if_$Id"
  mkdir -p "$WEB/if_$Id"

  # für alle Dateien im SlideShow Ordner, die nicht *.txt sind:
  find "$UserDir" -maxdepth 1 -type f \! -iname "*.txt" | sort | while read F; do
    File=`basename "$F"`

    # noch nicht im cache, da rein...
    # oder: cachefile ist älter als smbfile
    test -f "$CacheDir/$File.txt" \
    -o "$CacheDir/$File" -nt "$CacheDir/$File" \
    || cache_file "$UserDir" "$CacheDir" "$File" "$Id"

    # log "read_cache($CacheDir/$File.txt)"
    if [ -f "$CacheDir/$File.txt" ]; then
      while read media; do
        # mediafile ins web verlinken und .txt file damit erstellen
        md5=`echo "$media" | md5sum | cut -b1-32`
        # /var/cache/dsb/dsb1/SlideShow #1/bg04.jpg.d/bg04.jpg
        ln -s -f "$media" "$WEB/if_$Id/$md5.png"
        echo "if_$Id/$md5.png" >> "$WEB/if_$Id.txt"
        # xxx <video> ... 
        echo "<img id=\"$md5\" src=\"if_$Id/$md5.png\">" >> "$WEB/if_$Id.media"
      done < "$CacheDir/$File.txt"
    fi
  done
}

# Inhalt eines Templates lesen und zurück geben
read_template_file() {
  File="$1"

  # log "find \"$UserDir\" -iname \"$File\""
  find "$UserDir" -iname "$File" | while read f; do
    cat "$f"
  done
}

# -> setzt diese Variable: $LAYOUT
read_template_files() {
  # User Template
  UserDir="$SMB/${SECTIONS[$Id]}"

  LAYOUT=`read_template_file "#Layout.txt"`
  FILES=`echo "$LAYOUT" | grep -E '%\w*%'| cut -d% -f2`

  # alle %xyz% platzhalter ersetzen
  for x in $FILES; do
    # Ticker und Mediafiles sind anders!
    test "$x" = "TICKER" && continue
    test "$x" = "MEDIAFILES" && continue
    test "$x" = "IFRAME_STYLES" && continue
    test "$x" = "IFRAME_LINKS" && continue
    Content=`read_template_file "#$x"`
    LAYOUT=${LAYOUT/"%$x%"/"$Content"}
  done

  # log "find \"$UserDir\" -iname \"$File\""
  find "$UserDir" -iname "$File" | while read f; do
    cat "$f"
  done

  # reload kann überall drinnen sein
  RELOAD="dsb_checkreload(\"if_$Id.html.md5\", $DSB_RELOAD_TIME);"
  LAYOUT=${LAYOUT/'%DSB_RELOAD%'/"$RELOAD"}
}

# "Ticker" / IO
generate_iframe_ticker() {
  read_template_files

  # set up ticker <li's>
  if [ ! -z "$TICKER" ]; then
    T=""
    while read -r tline; do
      T="$T<li>$tline</li>"
    done <<< "$TICKER"
    LAYOUT=${LAYOUT/'%TICKER%'/"$T"}
  fi
  echo "$LAYOUT" > "$WEB/if_$Id.html"
}

# "SlideShow"
# - slideshow hat verzeichnis
# - alle bilder darin werden angezeigt
# - optionen via.?
generate_iframe_slideshow() {
  read_template_files

  echo -n > "$WEB/if_$Id.media"
  read_mediafiles
  MEDIAFILES=`cat "$WEB/if_$Id.media"`
  LAYOUT=${LAYOUT/'%MEDIAFILES%'/"$MEDIAFILES"}

  echo "$LAYOUT" > "$WEB/if_$Id.html"
}

# "Uhr" / IO
generate_iframe_uhr() {
  read_template_files
  echo "$LAYOUT" > "$WEB/if_$Id.html"
}

# "Webseite" / IO
generate_iframe_webseite() {
  read_template_files
  echo "$LAYOUT" > "$WEB/if_$Id.html"
}

# "Newsfeed" / IO
generate_iframe_newsfeed() {
  read_template_files
  echo "$LAYOUT" > "$WEB/if_$Id.html"
}

# "Wetter" / IO
generate_iframe_wetter() {
  read_template_files
  echo "$LAYOUT" > "$WEB/if_$Id.html"
}

# Frameset
generate_index() {
  log "Erstelle Index($Id), Type=$Type, Section=$Section"

  read_template_files

  IFRAME_STYLES=`cat "$CACHE/iframe-styles"`
  IFRAME_LINKS=`cat "$CACHE/iframe-links"`
  LAYOUT=${LAYOUT/'%IFRAME_STYLES%'/"$IFRAME_STYLES"}
  LAYOUT=${LAYOUT/'%IFRAME_LINKS%'/"$IFRAME_LINKS"}

  echo -n > "$WEB/if_$Id.media"
  read_mediafiles
  MEDIAFILES=`cat "$WEB/if_$Id.media"`
  LAYOUT=${LAYOUT/'%MEDIAFILES%'/"$MEDIAFILES"}

  echo "$LAYOUT" > "$WEB/indexX.html"

  # generate md5sum of frame
  cat "$WEB/indexX.html" | md5sum > "$WEB/indexX.html.md5"
}

generate_iframe() {
  # Update User Template from Samba Template
  rsync -aqu "$SMB/Templates/$Type/" "$SMB/$Section/"

  log "Erstelle Frame($Id), Type=$Type, Section=$Section"
  case "$Type" in
    "Wetter")
      generate_iframe_wetter
      ;;
    "Ticker")
      generate_iframe_ticker
      ;;
    "SlideShow")
      generate_iframe_slideshow
      ;;
    "Uhr")
      generate_iframe_uhr
      ;;
    "Webseite")
      generate_iframe_webseite
      ;;
    "Newsfeed")
      generate_iframe_newsfeed
      ;;
  esac

  if [ "$Type" != "Background" ]; then
    STYLES[$Id]=`read_template_file "#Rahmen.txt"`

    # style
    echo "iframe#id$Id {
  position: fixed;
  top: ${TOP[$Id]};
  left: ${LEFT[$Id]};
  width: ${WIDTH[$Id]};
  height: ${HEIGHT[$Id]};
  ${STYLES[$Id]}
}" >> "$CACHE/iframe-styles"

    echo "<iframe id=\"id$Id\" src=\"if_$Id.html\" scrolling=\"no\"></iframe>" \
      >> "$CACHE/iframe-links"

    # generate md5sum of frame
    cat "$WEB/if_$Id.html" | md5sum > "$WEB/if_$Id.html.md5"
  fi
}

generate_site() {
  # create directories / files in $SMB and $WEB
  echo -n > "$CACHE/iframe-styles"
  echo -n > "$CACHE/iframe-links"

  # 1a) Update directories
  rsync -qau "$LIBFILES/js/" "$WEB/js/"

  # 1b) Update Samba Templates (from System Templates)
  mkdir -p "$SMB/Templates"
  rsync -aqu "$TEMPLATES/" "$SMB/Templates/"

  # 2) reset FIFO Queue
  # wir bauen die ganze seite neu, alle anderen geänderten
  # files machen wir also indirekt mit!
  clean_fifo

  # 3) nur die iframes generieren
  for Id in ${!SECTIONS[@]}; do
    Section="${SECTIONS[$Id]}"
    Type="${TYPES[$Id]}"
    generate_iframe
  done

  # 4) nun den index für die iframes generieren
  for Id in ${!SECTIONS[@]}; do
    Type="${TYPES[$Id]}"
    test "$Type" = "Background" || continue
    Section="${SECTIONS[$Id]}"
    generate_index
  done

  # 4) cleanup
  rm -f "$CACHE/"iframe-*
}

# read layout file and set up the arrays:
# SECTIONS + TYPES + TOP + ...
read_layout() {
  local i="-1"
  while IFS=$'' read var val; do
    # section found
    if [[ $var == \[* ]]; then
      # sectionen die mit '#' beginnen, ignorieren
      x=`echo "$var"|tr -d "[]"|grep -v '^#'`
      test "x$x" = "x" && continue
      i=$((i+1))
      SECTIONS[$i]="$x"
    fi
    if [[ $var == Type=* ]]; then x=`echo "$var"|cut -b 6-`; TYPES[$i]="$x"; fi
    if [[ $var == Left=* ]]; then x=`echo "$var"|cut -b 6-`; LEFT[$i]="$x"; fi
    if [[ $var == Top=* ]]; then x=`echo "$var"|cut -b 5-`; TOP[$i]="$x"; fi
    if [[ $var == Width=* ]]; then x=`echo "$var"|cut -b 7-`; WIDTH[$i]="$x"; fi
    if [[ $var == Height=* ]]; then x=`echo "$var"|cut -b 8-`; HEIGHT[$i]="$x"; fi
  done < "$1"

  generate_site
}

remove_layout() {
  for i in ${!SECTIONS[@]}; do
    s="${SECTIONS[$i]}"
    unset SECTIONS[$i]
    unset TYPES[$i]
    unset LEFT[$i]
    unset TOP[$i]
    unset WIDTH[$i]
    unset HEIGHT[$i]
    rm -rf "$SMB/$s" "$WEB/$s" "$WEB/js/" \
     "$WEB/if_$i."* "$WEB/if_$i" "$WEB/index."* "$CACHE"/*
  done
}

# file was created @ $SMB
handle_create() {
  # log "handle_create file($basefile) dir($directory) orig($fullpath)"

  # special file "Layout.dsb"
  if [ "${basefile}" = "layout.dsb" ]; then
    log "Layout einlesen: [$directory/$basefile]"
    cat "$fullpath" | dos2unix > "$CACHE/$basefile"
    read_layout "$CACHE/$basefile"
    rm -f "$CACHE/$basefile"
  fi

  # check if some section was modified
  for i in ${!SECTIONS[@]}; do
    Section="${SECTIONS[$i],,}"
    if [ "${directory}" = "$Section" ]; then
      log "Datei erstellt/geändert:  [$directory/$basefile]"
      generate_site
    fi
  done
}

# file was removed in $SMB
handle_delete() {
  # log "handle_delete file($basefile) dir($directory) orig($fullpath)"

  # special file "Layout.dsb"
  if [ "${basefile}" = "layout.dsb" ]; then
    log "Layout enfernt..."
    remove_layout
  fi

  # check if some section was modified
  for i in ${!SECTIONS[@]}; do
    Section="${SECTIONS[$i],,}"
    if [ "${directory}" = "$Section" ]; then
      log "Datei gelöscht: [$directory/$basefile]"
      generate_site
    fi
  done
}

# some error checking and initializing
test -z $5 && error "Need 5 parameter!"
startup

# globals arrays for the layout
declare -A "SECTIONS" "TYPES" "LEFT" "TOP" "WIDTH" "HEIGHT" "STYLES"

# start inotifywait and put in background
inotifywait --monitor --recursive \
  --event create,close_write,delete,moved_to,moved_from \
  --format "|%w%f|%e|" "$SMB" > "$FIFO" 2>&1 &
INOTIFY_PID=$?

# big loop, which starts things on some events
waiting="yes"
while read -u $FIFO_FD -r inotifyline; do

  # wait for inotify to be ready
  if [ "$waiting" = "yes" ]; then
    test "$inotifyline" = "Watches established." || continue
    waiting="no"

    # touch all dsb files in smb root (force reading them)
    for i in "$SMB"/*[dD][sS][bB]; do
      test -f "$i" && touch "$i"
    done
    continue
  fi

  # thats the real input now
  fullpath=`echo $inotifyline|cut -d'|' -f2`
  event=`echo $inotifyline|cut -d'|' -f3`

  # remove $SMB prefix
  # /home/dsb/dsb1/path/file.txt -> path/file.txt
  filename=${fullpath#$SMB/}

  # we need a name, if there is none, we can't do anything...
  test "x$filename" = "x" && continue

  # lower case directory and basefile without smb prefix
  directory=`dirname "${filename,,}"`
  basefile=`basename "${filename,,}"`

  # .files are ignored
  [ "${basefile:0:1}" = "." ] && continue

  # debugging:
  # log "filename($filename) e($event)"
  # log "directory($directory) basefile($basefile) e($event)"
  # continue

  # create / delete
  case "$event" in
    "CREATE")
      handle_create
    ;;
    "CLOSE_WRITE,CLOSE")
      handle_create
    ;;
    "MOVED_TO")
      handle_create
    ;;
    "MOVED_FROM")
      handle_delete
    ;;
    "DELETE")
      handle_delete
    ;;
  esac
done
